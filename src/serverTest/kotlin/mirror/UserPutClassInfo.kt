//Generated by Lightning Kite's Mirror plugin
//AUTOMATICALLY GENERATED AND WILL BE OVERRIDDEN IF THIS MESSAGE IS PRESENT
package com.lightningkite.mirror.server

import com.lightningkite.kommon.exception.ExceptionNames
import com.lightningkite.lokalize.time.TimeStamp
import com.lightningkite.mirror.archive.server.security.HasPassword
import com.lightningkite.mirror.info.Indexed
import com.lightningkite.mirror.info.ThrowsTypes
import com.lightningkite.mirror.request.Request
import com.lightningkite.mirror.archive.database.*
import com.lightningkite.mirror.archive.model.*
import com.lightningkite.mirror.info.*
import kotlin.reflect.KClass

@Suppress("RemoveExplicitTypeArguments", "UNCHECKED_CAST", "USELESS_CAST")
object UserPutClassInfo: ClassInfo<User.Put> {

    override val kClass: KClass<User.Put> = User.Put::class
    override val modifiers: List<ClassInfo.Modifier> = listOf(ClassInfo.Modifier.Data)
    override val companion: Any? get() = null

    override val implements: List<Type<*>> = listOf(Type<SuspendMapPutRequest<Id, User>>(SuspendMapPutRequest::class, listOf(TypeProjection(Type<Id>(Id::class, listOf(), false), TypeProjection.Variance.INVARIANT), TypeProjection(Type<User>(User::class, listOf(), false), TypeProjection.Variance.INVARIANT)), false))

    override val packageName: String = "com.lightningkite.mirror.server"
    override val owner: KClass<*>? = User::class
    override val ownerName: String? = "User"

    override val name: String = "Put"
    override val annotations: List<AnnotationInfo> = listOf(AnnotationInfo("@ThrowsTypes", listOf(ExceptionNames.ForbiddenException)))
    override val enumValues: List<User.Put>? = null

    val fieldKey = FieldInfo<User.Put, Id>(this, "key", Type<Id>(Id::class, listOf(), false), false, { it.key as Id}, listOf())
    val fieldValue = FieldInfo<User.Put, User>(this, "value", Type<User>(User::class, listOf(), false), false, { it.value as User}, listOf())
    val fieldConditionIfExists = FieldInfo<User.Put, Condition<User>>(this, "conditionIfExists", Type<Condition<User>>(Condition::class, listOf(TypeProjection(Type<User>(User::class, listOf(), false), TypeProjection.Variance.INVARIANT)), false), false, { it.conditionIfExists as Condition<User>}, listOf())
    val fieldCreate = FieldInfo<User.Put, Boolean>(this, "create", Type<Boolean>(Boolean::class, listOf(), false), false, { it.create as Boolean}, listOf())

    override val fields:List<FieldInfo<User.Put, *>> = listOf(fieldKey, fieldValue, fieldConditionIfExists, fieldCreate)

    override fun construct(map: Map<String, Any?>): User.Put {
        //Gather variables
        val key:Id = map["key"] as Id
        val value:User = map["value"] as User
        val conditionIfExists:Condition<User> = map["conditionIfExists"] as Condition<User>
        val create:Boolean = map["create"] as Boolean
        //Handle the optionals
        
        //Finally do the call
        return User.Put(
            key = key,
            value = value,
            conditionIfExists = conditionIfExists,
            create = create
        )
    }

}